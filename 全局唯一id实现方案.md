---
title: 全局唯一id实现方案
date: 2023-11-01 20:50:29
tags:
---

分布式服务架构模式下全局唯一id实现方案
<!--more-->

### uuid

UUID是由一组32位数的16进制数字所构成 （8-4-4-4-12格式），
优势：生成方便，本地生成没有网络消耗。
缺点：无法作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能

### 数据库
主键id设计成不一样的自增值，然后设置固定的步长，步长的值即为分库或分表的数量。 
例步长为3 则分成3长表的主键id自增如下（1，4，7...）（2，5，8...）（3，6，9...）
优势：依赖于数据库自身不需要其他资源，并且ID号单调自增
缺点：ID发号性能瓶颈限制在单台MySQL的读写性能

### redis
redis提供了INCR和INCRBY这样的自增命令，所以能保证生成的 ID 肯定是唯一有序的。redis性能强劲，单机性能10万/s的qps。
如果高并发下，可以考虑redis集群。集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。
为了避免后期id自增过大，可以考虑与时间戳集合。高并发下可以采用redis+lua方式变成
优势：性能比较高，生成的数据是自增且有序
缺点：需要系统引进redis组件，增加了系统的配置复杂性。

### 雪花算法
Twitter开源的分布式ID生成算法，将64-bit位分割成4个部分。
* 第1位： 值为0，无意义
* 第2-41位: 时间戳雪花算法可用的时间年限是(1L<<41)/(1000L360024*365)=69 年的时间。
* 中间10位：表示机器数 (1L<<10) 最多支持1024台机器
* 最后12位：自增序列， (1L<<12) 最多可以表示4096个数
雪花算法在一毫秒支持1024台机器，且每一台机器上产生4096个有序的不重复的ID
优势： 雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高
缺点： 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态

### 美团Leaf
* Leaf-segment 数据库方案
在使用数据库的方案上，做了2个改变。一处是改为批量获取，每次获取一个segment(step决定大小)号段的值，一处是各个业务不同的发号需求用biz_tag字段来区分
```
表字段如下
｜ biz_tag ｜ max_id ｜    step ｜ desc ｜
｜ 业务key ｜当前已经分配了的最大id｜ 步长 ｜ 描述 ｜
｜'order' ｜ 3000  ｜ 1000 ｜ '订单' ｜
｜ 'job'  ｜ 10000 ｜ 2000 ｜ '岗位' ｜
｜'resume'｜ 1000  ｜ 100  ｜'简历'  ｜
```
同时Leaf-segment，为了解决TP999可能出现的尖刺的问题，提供了双buffer优化。
Leaf服务内部有两个号段缓存区segment，当前号段已下发50%时，如果下一个号段未更新，则另启线程异步更新下一个号段

* Leaf-snowflake方案
在snowflake的基方案上，引入Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID，
在解决时钟回拨的问题上是通过校验自身系统时间与 leaf_forever/${self}节点记录时间做比较然后启动报警的措施。